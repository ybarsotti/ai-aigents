#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/cli.ts
var import_node_path = require("path");
var import_node_util = require("util");
var import_promises = require("fs/promises");
var import_zod2 = require("zod");
var import_inference = require("@huggingface/inference");
var import_mcp_client = require("@huggingface/mcp-client");

// package.json
var version = "0.2.3";

// src/lib/types.ts
var import_zod = require("zod");
var ServerConfigSchema = import_zod.z.discriminatedUnion("type", [
  import_zod.z.object({
    type: import_zod.z.literal("stdio"),
    config: import_zod.z.object({
      command: import_zod.z.string(),
      args: import_zod.z.array(import_zod.z.string()).optional(),
      env: import_zod.z.record(import_zod.z.string()).optional(),
      cwd: import_zod.z.string().optional()
    })
  }),
  import_zod.z.object({
    type: import_zod.z.literal("http"),
    config: import_zod.z.object({
      url: import_zod.z.union([import_zod.z.string(), import_zod.z.string().url()]),
      options: import_zod.z.object({
        /**
         * Session ID for the connection. This is used to identify the session on the server.
         * When not provided and connecting to a server that supports session IDs, the server will generate a new session ID.
         */
        sessionId: import_zod.z.string().optional()
      }).optional()
    })
  }),
  import_zod.z.object({
    type: import_zod.z.literal("sse"),
    config: import_zod.z.object({
      url: import_zod.z.union([import_zod.z.string(), import_zod.z.string().url()]),
      options: import_zod.z.object({}).optional()
    })
  })
]);

// src/lib/utils.ts
var import_util = require("util");
function debug(...args) {
  if (process.env.DEBUG) {
    console.debug((0, import_util.inspect)(args, { depth: Infinity, colors: true }));
  }
}
function error(...args) {
  console.error(ANSI.RED + args.join("") + ANSI.RESET);
}
var ANSI = {
  BLUE: "\x1B[34m",
  GRAY: "\x1B[90m",
  GREEN: "\x1B[32m",
  RED: "\x1B[31m",
  RESET: "\x1B[0m"
};

// src/lib/mainCliLoop.ts
var readline = __toESM(require("readline/promises"));
var import_node_process = require("process");
async function mainCliLoop(agent) {
  const rl = readline.createInterface({ input: import_node_process.stdin, output: import_node_process.stdout });
  let abortController = new AbortController();
  let waitingForInput = false;
  async function waitForInput() {
    waitingForInput = true;
    const input = await rl.question("> ");
    waitingForInput = false;
    return input;
  }
  rl.on("SIGINT", async () => {
    if (waitingForInput) {
      await agent.cleanup();
      import_node_process.stdout.write("\n");
      rl.close();
    } else {
      abortController.abort();
      abortController = new AbortController();
      import_node_process.stdout.write("\n");
      import_node_process.stdout.write(ANSI.GRAY);
      import_node_process.stdout.write("Ctrl+C a second time to exit");
      import_node_process.stdout.write(ANSI.RESET);
      import_node_process.stdout.write("\n");
    }
  });
  process.on("uncaughtException", (err) => {
    import_node_process.stdout.write("\n");
    rl.close();
    throw err;
  });
  await agent.loadTools();
  import_node_process.stdout.write(ANSI.BLUE);
  import_node_process.stdout.write(`Agent loaded with ${agent.availableTools.length} tools:
`);
  import_node_process.stdout.write(agent.availableTools.map((t) => `- ${t.function.name}`).join("\n"));
  import_node_process.stdout.write(ANSI.RESET);
  import_node_process.stdout.write("\n");
  while (true) {
    const input = await waitForInput();
    for await (const chunk of agent.run(input, { abortSignal: abortController.signal })) {
      if ("choices" in chunk) {
        const delta = chunk.choices[0]?.delta;
        if (delta.content) {
          import_node_process.stdout.write(delta.content);
        }
        if (delta.tool_calls) {
          import_node_process.stdout.write(ANSI.GRAY);
          for (const deltaToolCall of delta.tool_calls) {
            if (deltaToolCall.id) {
              import_node_process.stdout.write(`<Tool ${deltaToolCall.id}>
`);
            }
            if (deltaToolCall.function.name) {
              import_node_process.stdout.write(deltaToolCall.function.name + " ");
            }
            if (deltaToolCall.function.arguments) {
              import_node_process.stdout.write(deltaToolCall.function.arguments);
            }
          }
          import_node_process.stdout.write(ANSI.RESET);
        }
      } else {
        import_node_process.stdout.write("\n\n");
        import_node_process.stdout.write(ANSI.GREEN);
        import_node_process.stdout.write(`Tool[${chunk.name}] ${chunk.tool_call_id}
`);
        import_node_process.stdout.write(chunk.content);
        import_node_process.stdout.write(ANSI.RESET);
        import_node_process.stdout.write("\n\n");
      }
    }
    import_node_process.stdout.write("\n");
  }
}

// src/cli.ts
var USAGE_HELP = `
Usage:
  tiny-agents [flags]
  tiny-agents run   "agent/id"
  tiny-agents serve "agent/id"

Available Commands:
  run         Run the Agent in command-line
  serve       Run the Agent as an OpenAI-compatible HTTP server

Flags:
  -h, --help      help for tiny-agents
  -v, --version   Show version information
`.trim();
var CLI_COMMANDS = ["run", "serve"];
function isValidCommand(command) {
  return CLI_COMMANDS.includes(command);
}
var FILENAME_CONFIG = "agent.json";
var FILENAME_PROMPT = "PROMPT.md";
async function loadConfigFrom(loadFrom) {
  try {
    return {
      configJson: await (0, import_promises.readFile)(loadFrom, { encoding: "utf8" })
    };
  } catch {
    if ((await (0, import_promises.lstat)(loadFrom)).isDirectory()) {
      try {
        let prompt;
        try {
          prompt = await (0, import_promises.readFile)((0, import_node_path.join)(loadFrom, FILENAME_PROMPT), { encoding: "utf8" });
        } catch {
          debug(`PROMPT.md not found in ${loadFrom}, continuing without prompt template`);
        }
        return {
          configJson: await (0, import_promises.readFile)((0, import_node_path.join)(loadFrom, FILENAME_CONFIG), { encoding: "utf8" }),
          prompt
        };
      } catch {
        error(`Config file not found in specified local directory.`);
        process.exit(1);
      }
    }
    const srcDir = (0, import_node_path.dirname)(__filename);
    const configDir = (0, import_node_path.join)(srcDir, "agents", loadFrom);
    try {
      let prompt;
      try {
        prompt = await (0, import_promises.readFile)((0, import_node_path.join)(configDir, FILENAME_PROMPT), { encoding: "utf8" });
      } catch {
        debug(`PROMPT.md not found in ${configDir}, continuing without prompt template`);
      }
      return {
        configJson: await (0, import_promises.readFile)((0, import_node_path.join)(configDir, FILENAME_CONFIG), { encoding: "utf8" }),
        prompt
      };
    } catch {
      error(`Config file not found in tiny-agents repo! Loading from the HF Hub is not implemented yet`);
      process.exit(1);
    }
  }
}
async function main() {
  const {
    values: { help, version: version2 },
    positionals
  } = (0, import_node_util.parseArgs)({
    options: {
      help: {
        type: "boolean",
        short: "h"
      },
      version: {
        type: "boolean",
        short: "v"
      }
    },
    allowPositionals: true
  });
  if (version2) {
    console.log(version);
    process.exit(0);
  }
  const command = positionals[0];
  const loadFrom = positionals[1];
  if (help) {
    console.log(USAGE_HELP);
    process.exit(0);
  }
  if (positionals.length !== 2 || !isValidCommand(command)) {
    error(`You need to call run or serve, followed by an agent id (local path or Hub identifier).`);
    console.log(USAGE_HELP);
    process.exit(1);
  }
  const { configJson, prompt } = await loadConfigFrom(loadFrom);
  const ConfigSchema = import_zod2.z.object({
    model: import_zod2.z.string(),
    provider: import_zod2.z.enum(import_inference.PROVIDERS_OR_POLICIES).optional(),
    endpointUrl: import_zod2.z.string().optional(),
    apiKey: import_zod2.z.string().optional(),
    servers: import_zod2.z.array(ServerConfigSchema)
  }).refine((data) => data.provider !== void 0 || data.endpointUrl !== void 0, {
    message: "At least one of 'provider' or 'endpointUrl' is required"
  });
  let config;
  try {
    const parsedConfig = JSON.parse(configJson);
    config = ConfigSchema.parse(parsedConfig);
  } catch (err) {
    error("Invalid configuration file:", err instanceof Error ? err.message : err);
    process.exit(1);
  }
  const agent = new import_mcp_client.Agent(
    config.endpointUrl ? {
      endpointUrl: config.endpointUrl,
      model: config.model,
      apiKey: config.apiKey ?? process.env.API_KEY ?? process.env.HF_TOKEN,
      servers: config.servers,
      prompt
    } : {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      provider: config.provider,
      model: config.model,
      apiKey: config.apiKey ?? process.env.API_KEY ?? process.env.HF_TOKEN,
      servers: config.servers,
      prompt
    }
  );
  if (command === "serve") {
    error(`Serve is not implemented yet, coming soon!`);
    process.exit(1);
  } else {
    debug(agent);
    await mainCliLoop(agent);
  }
}
main();
